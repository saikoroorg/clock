<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<title></title>
<link rel="icon" type="image/svg" href="icon.svg">
<link rel="apple-touch-icon" href="icon.png" sizes="192x192">
<link rel="manifest" href="manifest.json">
<style>
body {
	font-family: Courier, monospace, sans-serif;
	background-color: #fff;
}
a {
	color: #000;
	text-decoration: none;
}
small {
	font-size: 50%;
}
#container {
	width: 100%; height: 100%;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
}
#header {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: center; -webkit-align-items: center;
	opacity: 1;
}
#contents {
	width: 95%; height: 90%;
	flex: 1 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #ccc;
	opacity: 1;
}
.screen {
	width: 100%; height: 100%; left: 0; top: 0;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	background-color: #ccc;
}
#footer {
	width: 95%; margin: 0px;
	flex: 0 1 auto;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-end; -webkit-justify-content: flex-end;
	align-items: center; -webkit-align-items: center;
	opacity: 0.1;
}
.author,.version {
	font-size: 12px;
}
.logo {
	width: 160px; height: 60px; margin: 0px 16px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: flex-start; -webkit-justify-content: flex-start;
	align-items: center; -webkit-align-items: center;
	font-size: 24px;
}
.logo .icon {
	width: 40px; height: 40px; padding: 10px; margin-left: -28px;
}
.logo .title {
	user-select: none;
}
.menu {
	width: 80px; height: 40px; margin: 5px 0px;
	display: flex; display: -webkit-flex;
	flex-direction: row; -webkit-flex-direction: row;
	justify-content: space-between; -webkit-justify-content: space-between;
	align-items: flex-end; -webkit-align-items: flex-end;
	background-color: #ccc;
}
.menu a {
	width: 40px; height: 40px;
	display: flex; display: -webkit-flex;
	flex-direction: column; -webkit-flex-direction: column;
	justify-content: center; -webkit-justify-content: center;
	align-items: center; -webkit-align-items: center;
	font-size: 16px;
	text-decoration: none;
	transform: scale(1);
}
.menu .black {
	background-color: #000;
	color: #fff;
}
.menu .white {
	background-color: none;
	color: #000;
}
.menu small {
	font-size: 10px;
}
.menu a:hover {
	transform: scale(1);
	opacity: 0.6;
}
.menu a:active {
	transform: scale(0.9);
	opacity: 1;
}
@media (min-width: 600px) {
	#contents {
		flex-direction: row; -webkit-flex-direction: row;
		justify-content: center; -webkit-justify-content: center;
		align-items: center; -webkit-align-items: center;
	}
}
</style>
</head>
<body>
<div id="container">
	<h1 id="header">
		<div class="logo">
			<!--img class="icon" src="icon.svg"/!-->
			<a class="title"></a>
		</div>
		<div class="menu">
			<a class="black" id="changeCountButton" href="javascript:changeCount();">10</a>
			<a class="white" id="changePlayerButton" href="javascript:changePlayer();">x2</a>
		</div>
	</h1>
	<div id="contents">
		<div class="screen" id="screen1"></div>
		<div class="screen" id="screen2"></div>
	</div>
	<h6 id="footer">
		<div class="author">.</div>
		<div class="version">.</div>
	</h6>
</div>
<script>console.log = () => {};</script>
<script src="manifest.js"></script>
<script src="cube-api-0.8.js"></script>
<!--Menu--><script>
	var player = 2; // Player count.
	var count = 0; // Time count.
	var addition = 0; // Additional time count.
	var bonus = 0; // Bonus time count.
	var playing = -1; // Playing count.
	var locked = false; // Locked menu.

	const playerMax = 8; // Maximum player count.
	const numberMax = 6; // Maximum number of digits.
	const countMax = 999 * 60; // Maximum count.

	// Set clock.
	function setClock(c, a=0, b=0, p=0) {
		count = c > countMax ? countMax : c > 0 ? c : 0;
		addition = a > countMax ? countMax : a > 0 ? a : 0;
		bonus = b > 99 ? 99 : b > 0 ? b : 0;
		player = p > playerMax ? playerMax : p > 0 ? p : player;

		// Reset clock information.
		var e = document.getElementById("changeCountButton");
		if (e) {
			if (count > 0 && addition > 0) {
				e.innerHTML = "" + (count / 60) + " <small>-" + addition + "</small>";
			} else if (addition > 0) {
				e.innerHTML = "-" + addition + "";
			} else if (bonus > 0) {
				e.innerHTML = "" + (count / 60) + " <small>+" + bonus + "</small>";
			} else {
				e.innerHTML = "" + (count / 60) + "";
			}
		}
		e = document.getElementById("changePlayerButton");
		if (e) {
			e.innerHTML = "x" + player;
		}

		playing = -2; // Replay.
	};

	// Change couont.
	function changeCount() {
		if (!locked) {
			if (count > 5 * 60) {
				setClock(5 * 60, 0, 5, player); // 5m + 5s bonus time (Fisher)
			} else if (count > 0) {
				setClock(0, 10, 0, player); // 10s (Byoyomi)
			} else if (addition > 0) {
				setClock(0, 0, 0, player); // 0 (Free)
			} else {
				setClock(10 * 60, 30, 0, player); // 10m + 30s additional time (Byoyomi)
			}
		}
	};

	// Change player.
	function changePlayer() {
		if (!locked) {
			setClock(count, addition, bonus, cubeMod(player, playerMax) + 1);
		}
	};

	// Get query parameters.
	let params = cubeParamNumbers();

	// Additional time (Byoyomi) mode.
	if (cubeParamContains(0, "a")) {
		setClock(params[0] * 60, params[1], 0, params[2]);
		locked = true;

	// Bonus time (Fischer) mode.
	} else if (cubeParamContains(0, "b")) {
		setClock(params[0] * 60, 0, params[1], params[2]);
		locked = true;

	// Multi player mode.
	} else if (cubeParamContains(0, "x")) {
		setClock(params[0] * 60, 0, 0, params[1]);
		locked = true;

	// Simple (Kiremake) mode.
	} else if (params[0] > 0) {
		setClock(params[0] * 60, 0, 0, 2);
		locked = true;

	// Default.
	} else {
		setClock(10 * 60, 30, 0, 2);
	}

</script><!--/Menu-->
<!--Main--><script>(async()=>{

	// Resize screen.
	const screenMax = 2;
	var screens = [], joypads = [];
	for (let j = screenMax - 1; j >= 0; j--) {
		screens[j] = cubeScreen("screen", 40, 40);
		joypads[j] = cubeJoypad(screens[j]);
	}
	//cubeResizeScreen(80, 120);

	// Player.
	//const playerMax = 2; // Maximum player count.
	var playerCount = 2; // Player count.
	var playerIndex = 0; // Current player index.

	// Player state.
	PlayerState = class {
		constructor() {
			this.count = 0; // Time count.
			this.addition = 0; // Additional time count.
			this.bonus = 0; // Bonus time count.
			this.current = 0; // Current time count.
			this.consumed = 0; // Consumed time count.
			this.frames = []; // Sprite frames by current time.
			this.length = 0; // Sprite frame length.
		}
	};

	// Create player states.
	var players = [];
	for (let j = 0; j < playerMax; j++) {
		players[j] = new PlayerState();
	}

	// Button sprite.
	ButtonSprite = class {
		constructor() {
			this.sprite = null;
		}
	};

	// Create button sprites.
	const buttonMax = playerMax + 1; // Maximum button count.
	var buttons = [];
	for (let k = 0; k < buttonMax; k++) {
		buttons[k] = new ButtonSprite();
		buttons[k].sprite = await cubeSprite("image.svg", 40, 40);
	}

	// Number sprite.
	NumberSprite = class {
		constructor() {
			this.sprites = []; // Sprites.
			this.screen = null; // Target screen.
			this.length = 0; // Sprite length.
			this.center = cubeVector(); // Center position.
			this.width = 0; // Width of sprite.
			this.angle = 0; // Sprite angle.
		}
	};

	// Create number sprites.
	//const numberMax = 6; // Maximum number of digits.
	var numbers = [];
	for (let j = 0; j < buttonMax; j++) {
		numbers[j] = new NumberSprite();
		for (let i = 0; i < numberMax; i++) {
			numbers[j].sprites[i] = await cubeSprite("image.svg", 40, 40);
		}
	}

	// Playing states.
	//var playing = 0; // Playing count.
	var waiting = true; // Waiting to start flag.
	var pausing = false; // Pausing to start flag.
	var timeout = false; // Timeout flag.
	while (true) {

		// Reset count.
		if (playing < 0) {

			// Reset playing states.
			waiting = true;
			pausing = false;
			timeout = false;

			// Reset player states.
			playerCount = player;
			playerIndex = -1;
			for (let j = 0; j < playerCount; j++) {
				players[j].count = players[j].current = count;
				players[j].addition = addition;
				players[j].bonus = bonus;
				players[j].consumed = 0;
			}

			// Reset layouts.
			let sizes = [];
			for (let j = 0; j < screenMax; j++) {
				sizes[j] = cubeScreenSize(screens[j]);
			}
			if (playerCount <= 1) {
				for (let j = 0; j < 2; j++) {
					numbers[j].screen = screens[j > 0 ? 0 : 1];
					numbers[j].center.x = sizes[j].x / 2;
					numbers[j].center.y = sizes[j].y / 2;
					numbers[j].width = sizes[j].x * 0.8;
					numbers[j].angle = 0;
				}

			} else if (playerCount <= 2) {
				for (let j = 0; j < 2; j++) {
					numbers[j].screen = screens[j];
					numbers[j].center.x = sizes[j].x / 2;
					numbers[j].center.y = sizes[j].y / 2;
					numbers[j].width = sizes[j].x * 0.8;
					numbers[j].angle = 0;
				}

			} else {
				numbers[0].screen = screens[0];
				numbers[0].center.x = sizes[0].x / 2;
				numbers[0].center.y = sizes[0].y / 2;
				numbers[0].width = sizes[0].x * 0.8;
				numbers[0].angle = 0;

				if (playerCount <= 4) {
					for (let j = 0; j < playerCount; j++) {
						numbers[j + 1].screen = screens[1];
						numbers[j + 1].center.x = sizes[1].x * (j + 1) / (playerCount + 1);
						numbers[j + 1].center.y = sizes[1].y / 2;
						numbers[j + 1].width = sizes[1].x * 0.8 / playerCount;
						numbers[j + 1].angle = 0;
					}
				} else {
					let playerCount2 = cubeDiv(playerCount, 2);
					let playerCount1 = playerCount - playerCount2;
					for (let j = 0; j < playerCount1; j++) {
						numbers[j + 1].screen = screens[1];
						numbers[j + 1].center.x = sizes[1].x * (j + 1) / (playerCount1 + 1);
						numbers[j + 1].center.y = sizes[1].y * 1 / 3;
						numbers[j + 1].width = sizes[1].x * 0.8 / playerCount1;
						numbers[j + 1].angle = 0;
					}
					for (let j = playerCount1; j < playerCount; j++) {
						numbers[j + 1].screen = screens[1];
						numbers[j + 1].center.x = sizes[1].x * (j - playerCount1 + 1) / (playerCount2 + 1);
						numbers[j + 1].center.y = sizes[1].y * 2 / 3;
						numbers[j + 1].width = sizes[1].x * 0.8 / playerCount1;
						numbers[j + 1].angle = 0;
					}
				}
			}
		}

		// Start clock.
		let startTime = cubeTime();

		// Playing loop.
		for (playing = 1; playing >= 1; playing++) {
			let currentTime = cubeTime();
			let spendTime = currentTime - startTime;
			startTime = currentTime;

			// Update time count.
			if (!waiting && !pausing && !timeout) {
				let k = playerIndex >= 0 ? playerIndex : 0;
				players[k].consumed += spendTime / 1000; // Chess clock style.
				// players[k].consumed += cubeDiv(spendTime, 1000); // Stopwatch style.

				// Main time count.
				if (players[k].count > 0) {
					players[k].current = players[k].count - players[k].consumed;
					if (players[k].current <= 0) {
						players[k].current = players[k].count = 0;

						// Start additional time.
						if (players[k].addition > 0) {

							// Restart.
							playing = -1;

						// Time out.
						} else {
							timeout = true;
						}
					}

				// Additional time count.
				// (0 Additional time == Free time count)
				} else if (players[k].addition >= 0) {
					players[k].current = players[k].consumed;

					// Time out.
					if (players[k].addition > 0 && players[k].current >= players[k].addition) {
						players[k].current = players[k].addition;
						timeout = true;
					}
				}
			}

			// Update player states.
			for (let j = 0; j < playerCount; j++) {
				players[j].length = 0;

				// Seconds portion of the playing time.
				let r = cubeMod(players[j].current, 60);
				while (players[j].length < 2) {
					players[j].frames[players[j].length] = cubeMod(r, 10) + 1;
					r = cubeDiv(r, 10);
					players[j].length++;
				}

				// Time separator.
				let flashing = false;
				if (!waiting && !pausing && !timeout && j == playerIndex) {

					// Count down on main time count.
					if (players[j].count > 0) {
						if (cubeMod(players[j].current * 1000, 1000) < 500) {
							flashing = true;
						}

					// Count up on additional time count.
					} else {
						if (cubeMod(players[j].current * 1000, 1000) >= 500) {
							flashing = true;
						}
					}
				}

				// Colon mark for main time count.
				if (players[j].count > 0) {
					players[j].frames[players[j].length] = flashing ? 0 : 22;

				// Period mark for additional time count.
				} else {
					players[j].frames[players[j].length] = flashing ? 0 : 23;
				}
				players[j].length++;

				// Minute portion of the playing time.
				r = cubeDiv(players[j].current, 60);
				while (r > 0 || players[j].length < 5) {

					// Main time count.
					if (players[j].count > 0) {
						players[j].frames[players[j].length] = cubeMod(r, 10) + 1;

					// Additional time count.
					} else {
						if (r > 0 && players[j].current >= 60) {
							players[j].frames[players[j].length] = cubeMod(r, 10) + 1;
						} else {
							players[j].frames[players[j].length] = 0;
						}
					}
					r = cubeDiv(r, 10);
					players[j].length++;
				}
			}

			// Update solo player states.
			if (playerCount == 1) {
				players[1].length = 0;

				// Milliseconds portion of the playing time.
				let r = cubeMod(players[0].current * 1000, 1000);
				while (players[1].length < 3) {
					players[1].frames[players[1].length] = cubeMod(r, 10) + 1;
					r = cubeDiv(r, 10);
					players[1].length++;
				}

				// Time separator for milliseconds.
				players[1].frames[players[1].length] = 23;
				players[1].length++;
			}

			// Update button sprites.
			let p = playing >= 0 && playing < 6 ? 6 - playing : 0;
			for (let k = 0; k < buttonMax; k++) {

				// Linked button for solo player.
				if (playerCount <= 1) {
					if (k < 2) {
						let s = numbers[k].width * 0.025;
						cubeAnimate(25, buttons[k].sprite);

						// Waiting.
						if (waiting) {
							if (playerIndex > 0) {
								cubeDilute(0.8, buttons[k].sprite);
								cubeExpand(s - 0.02 * p, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							} else {
								cubeDilute(0.8, buttons[k].sprite);
								cubeExpand(s, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							}

						// Pausing.
						} else if (pausing) {
							cubeDilute(0.6, buttons[k].sprite);
							cubeExpand(s - 0.02 * p, buttons[k].sprite);
							cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);

						// Playing.
						} else {
							cubeDilute(1 - 0.04 * p, buttons[k].sprite);
							cubeExpand(s - 0.02 * p, buttons[k].sprite);
							cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
						}
					} else {
						cubeAnimate(0, buttons[k].sprite);
					}

				// Switching buttons for 2 players.
				} else if (playerCount == 2) {
					if (k < 2) {
						let s = numbers[k].width * 0.025;
						cubeAnimate(25, buttons[k].sprite);

						// Waiting.
						if (waiting) {
							if (k == playerIndex) {
								cubeDilute(0.8, buttons[k].sprite);
								cubeExpand(s - 0.02 * p, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							} else {
								cubeDilute(0.8, buttons[k].sprite);
								cubeExpand(s, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							}

						// Playing.
						} else {
							if (k == playerIndex) {
								cubeDilute(1 - 0.04 * p, buttons[k].sprite);
								cubeExpand(s - 0.02 * p, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							} else {
								cubeDilute(0.2, buttons[k].sprite);
								cubeExpand(s, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							}
						}
					} else {
						cubeAnimate(0, buttons[k].sprite);
					}

				// Cyclic buttons for 3+ playres.
				} else {
					if (k < playerCount + 1) {
						let s = numbers[k].width * (k > 0 ? 0.023 : 0.025);
						cubeAnimate(25, buttons[k].sprite);

						// Waiting.
						if (waiting) {
							if (k == 0) {
								if (playerIndex >= 0) {
									cubeDilute(0.8, buttons[k].sprite);
									cubeExpand(s - 0.02 * p, buttons[k].sprite);
									cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
								} else {
									cubeDilute(0.8, buttons[k].sprite);
									cubeExpand(s, buttons[k].sprite);
									cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
								}
							} else {
								cubeDilute(0.2, buttons[k].sprite);
								cubeExpand(s, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							}

						// Playing.
						} else {
							if (k == 0) {
								cubeDilute(1 - 0.04 * p, buttons[k].sprite);
								cubeExpand(s - 0.02 * p, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							} else if (k == playerIndex + 1) {
								cubeDilute(1 - 0.04 * p, buttons[k].sprite);
								cubeExpand(s - 0.005 * p, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							} else {
								cubeDilute(0.2, buttons[k].sprite);
								cubeExpand(s, buttons[k].sprite);
								cubeMove(numbers[k].center.x, numbers[k].center.y, buttons[k].sprite);
							}
						}
					} else {
						cubeAnimate(0, buttons[k].sprite);
					}
				}
			}

			// Update number angle.
			if (playerCount == 2) {
				let sizes = [], localPoses = [];
				for (let j = 0; j < screenMax; j++) {
					sizes[j] = cubeScreenSize(screens[j]);
					localPoses[j] = cubeScreenLocalPos(cubeVector(), screens[j]);
				}
				if (localPoses[1].y > localPoses[0].y + sizes[1].y / 2) {
					numbers[1].angle = 180;
				} else {
					numbers[1].angle = 0;
				}
			}

			// Update number sprites.
			for (let j = 0; j < buttonMax; j++) {
				let k = j;
				if (playerCount >= 3 && j < playerCount + 1) {
					if (j == 0) {
						k = playerIndex >= 0 ? playerIndex : 0;
					} else {
						k = j - 1;
					}
					numbers[j].length = players[k].length;
				} else if (playerCount <= 2 && j < 2) {
					numbers[j].length = players[k].length;
				} else {
					numbers[j].length = 0;
				}
				for (let i = 0; i < numberMax; i++) {
					if (j < playerCount + 1 && i < numbers[j].length) {
						cubeAnimate(players[k].frames[i], numbers[j].sprites[i]);
						let s = numbers[j].width * 0.04, sx = 0;
						cubeExpand(s / (numbers[j].length + 1), numbers[j].sprites[i]);
						cubeRotate(numbers[j].angle, numbers[j].sprites[i]);
						if (numbers[j].angle == 180) {
							sx = numbers[j].width * (0.5 - (numbers[j].length - i) / (numbers[j].length + 1));
						} else {
							sx = -numbers[j].width * (0.5 - (numbers[j].length - i) / (numbers[j].length + 1));
						}
						cubeMove(numbers[j].center.x + sx, numbers[j].center.y, numbers[j].sprites[i]);
					} else {
						cubeAnimate(0, numbers[j].sprites[i]);
					}
				}
			}

			// Draw button sprites.
			for (let k = 0; k < buttonMax; k++) {
				cubeDraw(buttons[k].sprite, screens[k > 0 ? 1 : 0]);
			}

			// Draw number sprites.
			for (let j = 0; j < playerCount + 1; j++) {
				for (let i = 0; i < numbers[j].length; i++) {
					cubeDraw(numbers[j].sprites[i], numbers[j].screen);
				}
			}

			// Wait for input.
			await cubeWait(10);

			if (!timeout) {

				// Read input.
				for (let j = 0; j < screenMax; j++) {
					await cubeReadJoypad(0, joypads[j]);
				}
				let action = (playerCount == 2 && !waiting) ? cubeJoypadAction(joypads[playerIndex]) :
					cubeJoypadAction(joypads[0]) || cubeJoypadAction(joypads[1]);
				let motion = (playerCount == 2 && !waiting) ? cubeJoypadMotion(joypads[playerIndex]) :
					cubeJoypadMotion(joypads[0]) || cubeJoypadMotion(joypads[1]);

				// Check trigger button.
				if (action) {

					// Start.
					if (waiting) {
						waiting = false;

						// Start from opposite side on 2 players mode.
						if (playerCount == 2) {
							if (cubeJoypadAction(joypads[0])) {
								playerIndex = 1;
							} else {
								playerIndex = 0;
							}
						} else {
							playerIndex = 0;
						}

					} else {

						// Update time count on turn end.
						if (players[playerIndex].count > 0) {
							let c = players[playerIndex].count - players[playerIndex].consumed + players[playerIndex].bonus;
							players[playerIndex].current = players[playerIndex].count = c > countMax ? countMax * 60 : c > 0 ? c : 0;
							players[playerIndex].consumed = 0;

						// Reset additional time count on turn end.
						} else if (players[playerIndex].addition > 0) {
							players[playerIndex].current = players[playerIndex].consumed = 0;
						}

						// Pause on solo mode.
						if (playerCount <= 1) {
							pausing = !pausing;

						// Switch players.
						} else {
							playerIndex = cubeMod(playerIndex + 1, playerCount);
						}
					}

					// Restart.
					playing = -1;

				// Check holding button.
				} else if (motion) {
					playing = 1;

					// Waiting to start from opposite side on 2 players mode.
					if (waiting) {
						if (playerCount == 2) {
							if (cubeJoypadMotion(joypads[0])) {
								playerIndex = 0;
							} else {
								playerIndex = 1;
							}
						} else {
							playerIndex = 0;
						}
					}
				}
			}
		}
	}
})();</script><!--/Main-->
</body>
</html>
